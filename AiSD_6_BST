#include <iostream>

using namespace std;

class Node {
private:
	int value;
	Node* left;
	Node* right;
	Node* parent;
public:
	Node(int v, Node* l, Node* r, Node* p);
	int getValue();
	Node* getLeft();
	Node* getRight();
	Node* getParent();
	void setValue(int v);
	void setLeft(Node* l);
	void setRight(Node* r);
	void setParent(Node* p);
};

class BSTree {
private:
	Node* root;
public:
	BSTree();
	Node* getRoot();
	bool empty(Node* p);
	void inorder(Node* p);
	void insert(int x);
	Node* search(int x);
	Node* minimum();
	Node* maximum();
	Node* successor(Node* p);
	Node* predecessor(Node* p);
	void del(Node* p);

	int size(Node* p);
	int height(Node* p);
	void clear(Node* p);
};


int main()
{
	cout << endl << "Zadanie 7.1 - test" << endl;
	BSTree* t = new BSTree();
	cout << "empty() 1 : " << t->empty(t->getRoot()) << endl;
	t->insert(8);
	t->insert(5);
	t->insert(12);
	t->insert(2);
	t->insert(1);
	t->insert(7);
	t->insert(3);
	t->insert(9);
	t->insert(14);
	t->insert(17);

	cout << endl;
	t->inorder(t->getRoot());

	return 0;
}

//Node

Node::Node(int v, Node* l, Node* r, Node* p) : value(v), left(l), right(r), parent(p) {};

int Node::getValue() {
	return value;
}

Node* Node::getLeft() {
	return left;
}

Node* Node::getRight() {
	return right;
}

Node* Node::getParent() {
	return parent;
}

void Node::setValue(int v) {
	value = v;
}

void Node::setLeft(Node* l) {
	left = l;
}

void Node::setRight(Node* r) {
	right = r;
}

void Node::setParent(Node* p) {
	parent = p;
}

//BSTree

BSTree::BSTree() : root(nullptr) {};

Node* BSTree::getRoot() {
	return root;
}

bool BSTree::empty(Node* p) {
	if (p == nullptr)
		return true;
	else return false;
}


void BSTree::insert(int x) {
	Node* newone = new Node(x, nullptr, nullptr, nullptr);
	Node* temp = root;

	if (root == nullptr)
	{
		root = newone;
		return;
	}

	bool stop = false;

	while (!stop) {
		if (temp->getValue() > x)
		{
			if(!empty(temp->getLeft()))
				temp = temp->getLeft();
			else
			{
				temp->setLeft(newone);
				newone->setParent(temp);
				stop = true;
			}
		}
		else if (temp->getValue() < x)
		{
			if (!empty(temp->getRight()))
				temp = temp->getRight();
			else {
				temp->setRight(newone);
				newone->setParent(temp);
				stop = true;

			}
		}
	}
}

void BSTree::inorder(Node* p){
	if (!empty(p)) {
		inorder(p->getLeft());
		cout << p->getValue() << " ";
		inorder(p->getRight());
	}
}
